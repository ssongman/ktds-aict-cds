
## 1.1 요구정의: 특정 서비스의 24/7 무중단 운영 및 기존 시스템과의 병행 운영

**목표:**
- 특정 서비스는 24/7 무중단 운영이 요구되며, 신규 시스템으로 완전히 전환되기 전까지 기존 시스템이 계속해서 운영되어야 합니다. 이 요구사항은 서비스 가용성을 극대화하고, 신규 시스템으로의 전환 과정에서 사용자에게 영향을 미치지 않도록 하는 것을 목표로 합니다.

**해결 방안:**

1. **고가용성(High Availability) 아키텍처 설계:**
   - **다중 가용성 영역(Availability Zones) 배포:** 서비스를 Azure Kubernetes Service(AKS) 클러스터의 여러 가용성 영역에 배포하여, 특정 영역에서 장애가 발생하더라도 다른 영역에서 서비스가 지속될 수 있도록 합니다. 이를 통해 자연재해나 네트워크 장애와 같은 지역적인 문제로 인한 서비스 중단을 방지할 수 있습니다.
   - **다중 지역(Multi-Region) 배포:** 더욱 높은 가용성을 요구하는 경우, 서비스를 Azure의 여러 지역에 배포하여, 한 지역에서 장애가 발생할 경우 다른 지역에서 서비스를 자동으로 제공할 수 있게 합니다. Azure Traffic Manager를 사용해 사용자 트래픽을 자동으로 다른 지역으로 라우팅하여 무중단 운영을 보장합니다.

2. **이중화 및 자동 복구(Failover):**
   - **이중화 구성:** 서비스의 핵심 구성 요소(데이터베이스, 메시징 큐, 파일 스토리지 등)를 이중화하여, 하나의 구성 요소가 실패하더라도 다른 구성 요소가 서비스를 지속적으로 제공할 수 있도록 합니다. 이를 위해 Azure SQL Database의 활성 지역 복제(Active Geo-Replication)와 같은 기능을 활용할 수 있습니다.
   - **자동 복구 및 재시작:** AKS 클러스터에서 자동 복구 및 재시작 기능을 활용하여, 장애가 발생한 컨테이너를 즉시 재시작하거나 다른 노드에서 새로운 인스턴스를 배포합니다. Kubernetes의 헬스 체크(Liveness Probes)를 사용해 서비스의 상태를 지속적으로 모니터링하고, 문제가 발생하면 자동으로 대응할 수 있도록 설정합니다.

3. **기존 시스템과의 병행 운영:**
   - **트래픽 라우팅 및 분산:** Azure API Management를 사용하여 트래픽을 기존 시스템과 신규 시스템 간에 분산시킵니다. 초기에는 대부분의 트래픽이 기존 시스템으로 라우팅되고, 신규 시스템이 점진적으로 완성되면서 일부 트래픽을 신규 시스템으로 전환합니다. 이렇게 하면 신규 시스템의 안정성을 검증하면서도 서비스 가용성을 유지할 수 있습니다.
   - **데이터 동기화:** 기존 시스템과 신규 시스템 간의 데이터 일관성을 유지하기 위해 데이터 동기화 전략을 수립합니다. Azure Data Factory 또는 Azure Event Grid를 활용하여 실시간으로 데이터를 동기화하거나, 특정 시점에서 데이터 일관성을 확보할 수 있도록 설계합니다.

4. **무중단 배포(Zero-Downtime Deployment):**
   - **블루-그린 배포:** 신규 시스템의 배포 시 블루-그린 배포 전략을 사용하여, 기존 시스템(블루)과 신규 시스템(그린)을 동시에 운영합니다. 신규 시스템이 완전히 검증된 후 트래픽을 그린 시스템으로 전환하며, 문제가 발생할 경우 즉시 블루 시스템으로 롤백할 수 있도록 합니다.
   - **카나리 배포:** 신규 시스템으로의 전환을 단계적으로 수행하기 위해 카나리 배포 전략을 사용합니다. 초기에는 일부 사용자만 신규 시스템을 사용하도록 하여 시스템의 안정성을 확인하고, 이후 점진적으로 전체 트래픽을 신규 시스템으로 전환합니다.

5. **모니터링 및 알림:**
   - **실시간 모니터링:** Azure Monitor와 Application Insights를 활용하여 서비스 상태, 성능 지표, 에러 로그 등을 실시간으로 모니터링합니다. 이 모니터링 시스템은 서비스의 가용성을 확인하고, 문제가 발생할 경우 즉각적인 알림을 통해 대응할 수 있도록 지원합니다.
   - **자동 알림:** 문제가 발생했을 때 대응 팀이 즉시 인지할 수 있도록 자동 알림 시스템을 설정합니다. 예를 들어, 장애가 발생하거나 성능 저하가 감지되면 즉시 대응할 수 있도록 이메일, SMS, 혹은 협업 도구(Slack, Teams 등)를 통해 알림을 보냅니다.


## 1.2 신규 시스템의 각 서비스는 독립적으로 배포 가능해야 하며, 실패 시 롤백이 용이해야 합니다.
### 요구정의: 신규 시스템의 각 서비스는 독립적으로 배포 가능해야 하며, 실패 시 롤백이 용이해야 함

**목표:**
- MSA(Microservices Architecture)로 전환된 신규 시스템의 각 마이크로서비스는 독립적으로 배포될 수 있어야 하며, 배포 중 문제가 발생할 경우 신속하고 용이하게 롤백할 수 있어야 합니다. 이를 통해 시스템의 유연성과 가용성을 극대화하고, 배포 과정에서의 위험을 최소화하는 것을 목표로 합니다.

**해결 방안:**

1. **독립적인 배포 파이프라인 구축:**
   - **서비스별 CI/CD 파이프라인 구성:** 각 마이크로서비스에 대해 독립적인 CI/CD(Continuous Integration/Continuous Deployment) 파이프라인을 구축합니다. 이를 통해 개별 서비스의 코드 변경사항이 다른 서비스에 영향을 미치지 않도록 합니다. 예를 들어, Azure DevOps 또는 GitHub Actions를 사용해 서비스별로 파이프라인을 설정하여, 코드 커밋 시 자동으로 빌드, 테스트, 배포가 진행되도록 합니다.
   - **버전 관리:** 각 마이크로서비스의 버전을 독립적으로 관리하여, 특정 서비스에 대한 업데이트가 다른 서비스와의 종속성을 최소화할 수 있도록 합니다. 이를 위해 서비스마다 별도의 릴리스 브랜치를 운영하고, Git을 활용한 태그 관리를 통해 배포 버전을 명확히 구분합니다.

2. **컨테이너화된 배포 방식:**
   - **Docker 컨테이너 활용:** 각 마이크로서비스를 Docker 컨테이너로 패키징하여 배포합니다. 이를 통해 서비스의 환경 독립성을 보장하고, 배포된 컨테이너가 동일한 환경에서 일관된 동작을 할 수 있도록 합니다. Kubernetes의 Deployment 리소스를 통해 컨테이너의 배포를 관리하고, 필요 시 특정 버전으로 쉽게 롤백할 수 있도록 합니다.
   - **Helm 차트 사용:** 배포의 일관성과 관리를 위해 Helm 차트를 사용하여 Kubernetes에서 각 서비스의 배포를 정의합니다. 이를 통해 환경 변수, 설정 파일 등을 쉽게 관리하고, 여러 배포 환경(dev, staging, prod)에서 일관된 배포를 수행할 수 있습니다.

3. **무중단 배포(Zero-Downtime Deployment):**
   - **롤링 업데이트:** Kubernetes의 롤링 업데이트 전략을 사용하여 서비스의 새로운 버전을 무중단으로 배포합니다. 롤링 업데이트는 점진적으로 새로운 버전을 배포하면서 기존 버전을 교체해나가는 방식으로, 트래픽에 영향을 주지 않고 배포를 완료할 수 있습니다.
   - **블루-그린 배포:** 배포 시 새로운 버전을 블루 환경 또는 그린 환경에 배포한 후, 검증이 완료되면 트래픽을 전환하는 방식입니다. 문제가 발생하면 트래픽을 원래 환경으로 다시 전환하여 롤백할 수 있습니다. Azure Traffic Manager나 Azure Front Door를 사용해 트래픽을 쉽게 전환할 수 있습니다.

4. **롤백 전략 및 자동화:**
   - **자동 롤백 설정:** 배포된 새로운 버전에서 문제가 발견되면, 자동으로 이전 버전으로 롤백할 수 있는 기능을 설정합니다. Kubernetes의 `kubectl rollout undo` 명령을 통해 이전 Deployment 상태로 쉽게 롤백할 수 있으며, Helm 차트의 기능을 활용해 이전 버전으로의 롤백을 자동화할 수 있습니다.
   - **배포 전 검증 단계:** 새로운 버전이 프로덕션 환경에 배포되기 전에 스테이징 환경에서 자동화된 테스트를 통해 충분히 검증합니다. 이 검증 단계에서 문제가 없음을 확인한 후에만 프로덕션으로 배포하며, 문제가 발생하면 즉시 롤백할 수 있도록 준비합니다.

5. **모니터링 및 알림 시스템:**
   - **배포 모니터링:** Azure Monitor와 Application Insights를 활용해 배포 과정과 배포 후 서비스의 상태를 실시간으로 모니터링합니다. 배포 중 문제가 발생하면 이를 신속하게 탐지하고, 롤백이 필요한 상황인지 판단할 수 있도록 합니다.
   - **자동 알림:** 문제가 감지되었을 때 즉시 관련 팀에 알림을 보내는 자동화된 알림 시스템을 설정합니다. Azure DevOps나 Slack, Microsoft Teams 등과 연동해 알림을 받을 수 있으며, 문제의 심각도에 따라 자동으로 롤백을 트리거할 수 있습니다.

**결론:**
- 신규 시스템의 각 마이크로서비스는 독립적으로 배포될 수 있도록 CI/CD 파이프라인과 컨테이너화된 배포 방식을 활용하여 설정합니다. 이를 통해 배포 시 다른 서비스에 영향을 주지 않고, 신속하게 업데이트를 진행할 수 있습니다.
- 무중단 배포와 롤백 전략을 통해 배포 과정에서의 서비스 중단을 방지하고, 배포 실패 시 신속하게 이전 상태로 복원할 수 있도록 설계합니다.
- 실시간 모니터링과 자동 알림 시스템을 통해 배포 과정의 문제를 신속하게 탐지하고 대응할 수 있도록 하여, 안정적인 서비스 운영을 보장합니다.

## 1.3 기존 시스템과 신규 시스템 간의 데이터 동기화가 필수적이며, 데이터 일관성을 유지해야 합니다.
### 요구정의: Azure 서비스 기반으로 기존 시스템과 신규 시스템 간의 데이터 동기화 및 데이터 일관성 유지

**목표:**
- 기존 시스템과 신규 시스템 간의 데이터 동기화가 필수적이며, 이 과정에서 데이터 일관성을 유지해야 합니다. Azure 서비스를 활용하여 두 시스템 간의 데이터가 실시간으로 동기화되고, 일관성이 보장되도록 하여 시스템 전환 중에도 사용자 경험이 일관되게 유지되는 것을 목표로 합니다.

**해결 방안:**

1. **Azure 서비스를 활용한 데이터 동기화 전략:**

   - **Azure SQL Database Active Geo-Replication:**
     - 기존 시스템과 신규 시스템이 모두 Azure SQL Database를 사용한다면, Active Geo-Replication을 활용하여 데이터를 여러 지역에 걸쳐 실시간으로 복제할 수 있습니다. 이를 통해 데이터베이스의 고가용성을 보장하며, 양 시스템 간 데이터 일관성을 유지할 수 있습니다.

   - **Azure Data Factory:**
     - Azure Data Factory를 사용하여 기존 시스템의 데이터를 신규 시스템으로 ETL(Extract, Transform, Load) 방식으로 동기화합니다. 데이터 변환 및 이동을 위한 파이프라인을 설정하여, 기존 데이터베이스의 변경 사항을 주기적으로 추출하고, 신규 시스템으로 로드합니다.
     - Azure Data Factory는 고도의 자동화된 데이터 통합 서비스를 제공하며, 대규모 데이터 이동을 신속하게 처리할 수 있습니다.

   - **Azure Event Grid 및 Azure Functions:**
     - 데이터 변경 이벤트를 캡처하고 실시간으로 처리하기 위해 Azure Event Grid와 Azure Functions를 활용합니다. 기존 시스템에서 발생하는 데이터 변경 이벤트를 Azure Event Grid를 통해 캡처하고, 이를 트리거로 Azure Functions에서 데이터 동기화 작업을 수행합니다.
     - 이 이벤트 기반 아키텍처는 데이터 동기화의 실시간성을 높여주며, 비동기적으로 동작하여 시스템의 결합도를 줄입니다.

   - **Azure Cosmos DB Change Feed:**
     - Azure Cosmos DB를 사용하는 경우, Change Feed 기능을 활용하여 데이터베이스의 변경 사항을 실시간으로 스트리밍하고, 이를 신규 시스템으로 전송할 수 있습니다. Change Feed는 데이터의 삽입, 업데이트, 삭제 등을 감지하고, 이를 트리거로 하여 다른 시스템에 데이터를 동기화할 수 있습니다.

   - **Azure Service Bus:**
     - 메시지 기반의 데이터 동기화를 위해 Azure Service Bus를 활용할 수 있습니다. 기존 시스템에서 발생하는 데이터 변경 사항을 메시지로 Azure Service Bus에 게시하고, 신규 시스템에서 이 메시지를 소비하여 데이터를 동기화합니다.
     - 이 방식은 비동기적으로 동작하며, 대량의 메시지를 안정적으로 처리할 수 있어 확장성이 뛰어납니다.

2. **데이터 일관성 유지 방안:**

   - **분산 트랜잭션 관리:**
     - Azure SQL Database에서 분산 트랜잭션을 관리하여, 데이터 동기화 시 두 시스템 간의 트랜잭션 일관성을 보장합니다. Azure Distributed Transactions 기능을 사용하여 다중 데이터베이스에 걸친 트랜잭션을 일관되게 관리할 수 있습니다.

   - **SAGA 패턴 구현:**
     - 마이크로서비스 아키텍처에서 트랜잭션을 처리할 때 SAGA 패턴을 도입하여 데이터 일관성을 유지합니다. Azure Logic Apps 또는 Azure Functions를 사용하여 SAGA의 각 단계(트랜잭션 및 보상 트랜잭션)를 관리하며, 데이터 변경이 실패할 경우 보상 트랜잭션을 통해 롤백할 수 있습니다.

   - **데이터 검증 및 충돌 처리:**
     - Azure Data Factory와 Azure Stream Analytics를 사용해 데이터 동기화 중 발생할 수 있는 데이터 불일치나 충돌을 감지하고 처리합니다. 데이터 이동 후, Azure Stream Analytics를 통해 실시간으로 데이터를 분석하고, 일관성 문제가 발생하면 이를 자동으로 수정하거나 알림을 통해 수동 검토할 수 있도록 합니다.

   - **최종 일관성 전략:**
     - 신규 시스템이 완전히 구축되기 전까지는 최종 일관성(Eventual Consistency) 모델을 적용할 수 있습니다. Azure Cosmos DB는 이러한 일관성 모델을 지원하며, 데이터를 여러 리전으로 분산할 때 최종적으로 일관된 상태를 보장할 수 있습니다.

3. **모니터링 및 알림:**

   - **Azure Monitor 및 Application Insights:**
     - Azure Monitor와 Application Insights를 통해 데이터 동기화 상태와 일관성 지표를 실시간으로 모니터링합니다. 이 도구들을 사용해 두 시스템 간의 데이터 동기화 속도, 오류 발생률, 트랜잭션 처리 상태 등을 지속적으로 관찰하며, 이상이 감지될 경우 즉시 대응할 수 있도록 합니다.

   - **자동화된 알림 시스템:**
     - Azure Logic Apps와 Azure Monitor를 연동하여 데이터 동기화 중 문제가 발생하면 자동으로 알림을 보내도록 설정합니다. 예를 들어, 동기화 실패 시 특정 팀에게 이메일 또는 SMS 알림이 발송되며, 문제가 심각할 경우 자동으로 대응 조치를 실행할 수 있도록 워크플로우를 구성합니다.

4. **백업 및 복구 전략:**

   - **정기 백업 및 복구 테스트:**
     - Azure Backup을 활용해 기존 시스템과 신규 시스템의 데이터를 정기적으로 백업합니다. 동기화 과정에서 데이터 손실이나 불일치가 발생할 경우, 이 백업 데이터를 사용해 신속히 복구할 수 있습니다.
     - 백업 및 복구 프로세스는 주기적으로 테스트하여, 데이터 무결성이 보장되도록 합니다.

**결론:**
- Azure 서비스(예: Azure Data Factory, Azure Event Grid, Azure Functions 등)를 활용하여 기존 시스템과 신규 시스템 간의 데이터 동기화를 실시간으로 관리하고, 데이터 일관성을 유지할 수 있습니다.
- 분산 트랜잭션 관리와 SAGA 패턴을 도입하여 데이터 동기화 중 발생할 수 있는 일관성 문제를 효과적으로 처리하며, 모니터링 및 알림 시스템을 통해 실시간으로 동기화 상태를 감시하고 대응할 수 있습니다.
- 정기적인 백업과 복구 테스트를 통해 데이터 손실 시 빠르게 복구할 수 있는 체계를 구축하여, 시스템 전환 중에도 데이터 무결성과 일관성을 유지할 수 있습니다.

## 1.4 새로운 기능 개발은 신규 시스템에서 이루어지며, 단계적으로 기존 시스템에서 마이크로서비스로 전환되어야 합니다
### 요구정의: Azure 기반 MSA로 전환하면서 새로운 기능 개발 및 단계적 전환

**목표:**
- 기존 모놀리식(단일체) 시스템을 Azure 기반의 MSA(Microservices Architecture)로 전환하는 과정에서, 새로운 기능 개발은 신규 시스템(마이크로서비스)에서 이루어지며, 기존 시스템의 기능을 점진적으로 마이크로서비스로 전환해 나가는 것이 목표입니다. 이 과정에서 기존 시스템의 안정성을 유지하면서 신규 시스템의 유연성과 확장성을 확보하는 것이 핵심입니다.

**해결 방안:**

1. **새로운 기능 개발을 위한 마이크로서비스 설계:**

   - **독립적인 마이크로서비스 개발:**
     - 새로운 기능은 신규 시스템에서 독립적인 마이크로서비스로 설계 및 개발됩니다. 이를 통해 기능별로 독립적인 배포와 확장이 가능해지며, 신규 기능이 기존 시스템에 영향을 미치지 않도록 격리할 수 있습니다.
     - Azure Kubernetes Service(AKS)를 활용해 각 마이크로서비스를 컨테이너화하고, Azure DevOps 또는 GitHub Actions를 이용한 CI/CD 파이프라인을 통해 자동화된 빌드, 테스트, 배포를 구현합니다.

   - **API 기반 통신:**
     - 신규 기능은 Azure API Management를 통해 기존 시스템과 통신하도록 설계됩니다. 기존 시스템이 필요할 경우, 신규 마이크로서비스의 API를 호출해 기능을 사용할 수 있도록 API Gateway를 설정합니다. 이를 통해 기존 시스템과 신규 시스템 간의 통합이 원활하게 이루어집니다.

   - **서버리스 아키텍처 도입:**
     - 특정한 간단한 기능이나 이벤트 기반 작업은 Azure Functions를 사용해 서버리스 방식으로 개발할 수 있습니다. 이를 통해 신규 기능을 빠르게 개발하고 배포할 수 있으며, 필요 시 자동으로 확장할 수 있습니다.
     - Azure Logic Apps를 활용해 워크플로우를 자동화하고, 다양한 Azure 서비스와 통합하여 기능 개발의 효율성을 높일 수 있습니다.

2. **기존 시스템의 단계적 마이크로서비스 전환:**

   - **Strangler Fig 패턴 적용:**
     - Strangler Fig 패턴을 적용하여 기존 시스템의 특정 기능을 점진적으로 마이크로서비스로 전환합니다. 새로운 기능이 추가될 때마다, 기존 시스템의 일부 기능을 신규 시스템으로 이관하거나, 신규 기능을 기존 시스템을 통하지 않고 바로 마이크로서비스로 구현합니다.
     - 이 패턴을 통해 기존 시스템을 점진적으로 폐기하면서도 시스템 전환의 리스크를 최소화할 수 있습니다.

   - **프로토콜 및 데이터 호환성 유지:**
     - 기존 시스템과 신규 시스템 간의 통신 프로토콜 및 데이터 포맷의 호환성을 유지하여, 전환 과정 중에도 두 시스템이 원활히 상호작용할 수 있도록 합니다. 이를 위해, 데이터 포맷 변환이나 중간 브릿지 서비스(Data Bridge Service)를 활용하여 데이터의 일관성을 유지합니다.
     - Azure API Management를 통해 API 버저닝을 관리하여, 기존 시스템이 새로운 마이크로서비스와 문제없이 통신할 수 있도록 지원합니다.

   - **데이터 동기화 및 일관성 유지:**
     - 기존 시스템과 마이크로서비스 간의 데이터 동기화를 보장하기 위해 Azure Data Factory, Azure Event Grid, Azure Service Bus 등을 활용하여 실시간 데이터 동기화를 구현합니다. 이를 통해 기존 시스템의 데이터와 신규 시스템의 데이터가 일관되게 유지되도록 합니다.
     - 데이터 동기화 과정에서 발생할 수 있는 일관성 문제를 처리하기 위해, SAGA 패턴과 같은 분산 트랜잭션 관리 기법을 도입합니다.

3. **점진적 전환을 위한 배포 전략:**

   - **카나리 배포:**
     - 신규 기능이 처음으로 도입될 때 카나리 배포 전략을 사용하여, 전체 사용자 중 일부만 신규 시스템으로 전환하고, 나머지는 기존 시스템을 사용하게 합니다. 이를 통해 신규 기능의 안정성을 검증한 후, 점진적으로 전체 사용자에게 배포할 수 있습니다.
     - Azure Traffic Manager를 활용해 트래픽을 세분화하여 기존 시스템과 신규 시스템 간에 분산시킬 수 있습니다.

   - **블루-그린 배포:**
     - 새로운 마이크로서비스로 전환 시, 블루-그린 배포 전략을 적용해 무중단 전환을 보장합니다. 기존 시스템(블루)과 신규 시스템(그린)을 동시에 운영하면서, 신규 시스템의 안정성이 확인되면 트래픽을 그린 시스템으로 전환합니다.
     - Azure Front Door를 사용해 트래픽을 관리하고, 문제 발생 시 기존 시스템으로 빠르게 롤백할 수 있습니다.

4. **모니터링 및 품질 관리:**

   - **모니터링 및 로깅:**
     - Azure Monitor와 Application Insights를 활용해 신규 시스템의 상태와 성능을 실시간으로 모니터링합니다. 신규 마이크로서비스의 성능 지표, 오류 발생률, 사용자 반응 등을 지속적으로 추적하고 분석합니다.
     - 실시간 로그 수집과 분석을 통해, 신규 시스템에서 발생할 수 있는 문제를 조기에 발견하고 대응할 수 있습니다.

   - **자동화된 테스트 및 품질 보증:**
     - 각 마이크로서비스의 배포 전후로 자동화된 테스트를 수행하여, 기능의 품질을 보장합니다. Azure DevOps의 CI/CD 파이프라인에서 자동화된 유닛 테스트, 통합 테스트, 로드 테스트를 실행하여, 새로운 기능이 기존 시스템에 미치는 영향을 최소화합니다.

**결론:**
- Azure 기반의 MSA로 전환하는 과정에서 신규 기능은 독립적인 마이크로서비스로 개발되어, 기존 시스템과의 통합을 유지하면서도 유연하게 배포될 수 있습니다.
- Strangler Fig 패턴을 통해 기존 시스템의 기능을 점진적으로 마이크로서비스로 전환하면서, 시스템의 안정성을 유지합니다.
- 카나리 배포와 블루-그린 배포 전략을 통해 신규 시스템으로의 전환을 무중단으로 수행하며, Azure의 다양한 모니터링 및 자동화 도구를 활용해 전환 과정에서 발생할 수 있는 문제를 효과적으로 관리합니다.
- 최종적으로, Azure 서비스들을 적극적으로 활용하여 시스템 전환의 리스크를 줄이고, MSA의 장점을 최대한 활용할 수 있는 유연하고 확장 가능한 아키텍처를 구축합니다.

### Strangler Fig 패턴
**Strangler Fig 패턴**은 기존의 모놀리식(단일체) 애플리케이션을 점진적으로 마이크로서비스 아키텍처로 전환하는 전략을 설명하는 소프트웨어 리팩토링 패턴입니다. 이 패턴의 이름은 열대 우림에서 자라는 "목을 조르는 무화과 나무(Strangler Fig)"에서 유래했습니다. 이 나무는 다른 나무의 외부에서 자라면서 점차 그 나무를 덮고, 결국 원래의 나무를 대체하게 됩니다. 이 개념을 소프트웨어 시스템에 적용한 것이 Strangler Fig 패턴입니다.

### Strangler Fig 패턴의 개념

- **기존 시스템의 유지:** 기존의 모놀리식 애플리케이션은 그대로 유지합니다. 처음부터 시스템 전체를 재구축하지 않고, 시스템을 점진적으로 개선해 나갑니다.
  
- **기능 단위의 마이크로서비스화:** 기존 시스템의 특정 기능을 새롭게 개발된 마이크로서비스로 대체합니다. 이 과정에서 기존 기능은 비활성화하거나 제거하지 않고, 신규 마이크로서비스가 해당 기능을 대신하도록 합니다.

- **점진적 전환:** 기존 시스템의 각 부분을 점진적으로 마이크로서비스로 전환해 나갑니다. 시간이 지남에 따라, 점점 더 많은 기능이 마이크로서비스로 전환되고, 결국 기존 시스템은 점차 사용되지 않게 됩니다.

- **완전한 대체:** 최종적으로, 모든 기능이 마이크로서비스로 전환되고 나면, 기존의 모놀리식 애플리케이션은 더 이상 필요하지 않게 되어 폐기될 수 있습니다. 이때 새로운 시스템은 완전히 마이크로서비스로 구성된 상태가 됩니다.

### Strangler Fig 패턴의 장점

1. **리스크 감소:** 전체 시스템을 한 번에 전환하는 것이 아니라, 단계적으로 전환하기 때문에 리스크를 줄일 수 있습니다. 새로운 기능이 추가될 때마다 하나씩 마이크로서비스로 전환하므로, 시스템 안정성이 높아집니다.

2. **유연성:** 특정 기능이 문제가 있거나, 전환 과정에서 문제가 발생하더라도 기존 시스템을 계속 사용할 수 있습니다. 문제가 해결되면 다시 전환을 시도할 수 있습니다.

3. **점진적 투자:** 전환 과정이 단계적으로 이루어지므로, 초기 비용과 리소스를 줄일 수 있으며, 시간에 따라 필요한 리소스를 조정할 수 있습니다.

4. **사용자에게 영향을 최소화:** 사용자는 전환 과정 중에도 지속적으로 기존 시스템을 사용할 수 있기 때문에, 새로운 기능 추가나 시스템 전환으로 인한 중단이나 큰 변화를 경험하지 않습니다.

### Strangler Fig 패턴의 적용 예시

- **API Gateway를 통한 트래픽 관리:** 기존 시스템에 대한 요청을 API Gateway를 통해 전달하고, 새로운 마이크로서비스가 준비되면 API Gateway에서 이 트래픽을 마이크로서비스로 라우팅합니다. 기존 시스템의 기능이 하나씩 마이크로서비스로 전환되면서, API Gateway를 통해 점진적으로 트래픽이 새로운 시스템으로 이동하게 됩니다.

- **신규 기능을 마이크로서비스로 구현:** 새로운 기능을 추가할 때, 이를 기존 시스템이 아닌 마이크로서비스로 구현하여 배포합니다. 이 기능이 안정화되고 성공적으로 운영되면, 점차적으로 관련된 기존 기능을 마이크로서비스로 전환합니다.

### 결론

Strangler Fig 패턴은 기존 시스템을 단계적으로 새로운 아키텍처로 전환할 때 효과적인 접근 방식입니다. 전체 시스템의 리팩토링을 통해 리스크를 줄이고, 사용자에게 최소한의 영향을 미치면서 새로운 마이크로서비스 아키텍처로 전환할 수 있는 방법을 제공합니다. 이 패턴은 대규모 시스템 전환에서 유용하게 사용될 수 있습니다.


## 1.5 시스템의 확장성이 중요하며, 트래픽 증가 시 자동으로 리소스를 확장할 수 있어야 합니다.

### 요구정의: AKS를 활용하여 시스템의 확장성 확보 및 트래픽 증가 시 자동 리소스 확장

**목표:**
- Azure Kubernetes Service(AKS)를 활용하여 시스템의 확장성을 확보하고, 트래픽이 증가할 때 자동으로 리소스를 확장할 수 있어야 합니다. 이를 통해 시스템이 사용자 수요에 따라 동적으로 확장되며, 성능 저하 없이 안정적인 서비스를 제공하는 것을 목표로 합니다.

**해결 방안:**

1. **AKS 클러스터 자동 확장(AKS Cluster Autoscaler):**

   - **클러스터 오토스케일러(Cluster Autoscaler):**
     - AKS에서 제공하는 클러스터 오토스케일러를 사용하여, 클러스터 내의 노드 수를 자동으로 조정합니다. 클러스터 오토스케일러는 클러스터에 추가적인 리소스가 필요할 때 자동으로 노드를 추가하고, 필요하지 않을 때는 노드를 제거하여 비용을 최적화합니다.
     - 예를 들어, 트래픽이 증가해 Pod이 더 많은 리소스를 요구할 때, 오토스케일러가 추가 노드를 프로비저닝하여 리소스 부족 문제를 방지합니다.

   - **노드 풀(Node Pool) 관리:**
     - AKS에서는 다양한 크기와 유형의 노드 풀을 구성하여 서로 다른 리소스 요구사항을 가진 워크로드를 처리할 수 있습니다. 예를 들어, CPU 집약적인 서비스와 메모리 집약적인 서비스는 각기 다른 노드 풀에서 실행되도록 구성하여 리소스를 최적화할 수 있습니다.
     - 노드 풀별로 오토스케일링 정책을 적용하여, 특정 노드 풀만 확장하거나 축소할 수 있습니다. 이를 통해 특정 워크로드의 특성에 맞는 유연한 확장이 가능합니다.

2. **Horizontal Pod Autoscaler (HPA):**

   - **HPA를 통한 Pod 확장:**
     - Horizontal Pod Autoscaler(HPA)를 사용하여 각 마이크로서비스의 Pod 수를 자동으로 확장합니다. HPA는 CPU 사용률, 메모리 사용량, 또는 사용자 정의 메트릭을 기준으로 Pod 수를 조정합니다.
     - 예를 들어, CPU 사용률이 70%를 초과할 경우, HPA가 추가 Pod을 생성하여 트래픽 증가에 대응하고, 트래픽이 줄어들면 자동으로 Pod 수를 줄여 리소스를 효율적으로 사용합니다.

   - **사용자 정의 메트릭 기반 확장:**
     - 기본적인 CPU 및 메모리 사용량 외에도, Application Insights 또는 Azure Monitor에서 제공하는 사용자 정의 메트릭을 기반으로 HPA를 설정할 수 있습니다. 예를 들어, 특정 API 응답 시간이나 큐의 대기 길이를 기준으로 Pod을 확장하도록 설정할 수 있습니다.

3. **Azure Load Balancer 및 Ingress Controller:**

   - **트래픽 관리 및 분산:**
     - AKS는 Azure Load Balancer를 통해 외부 트래픽을 클러스터 내의 서비스로 분산시킵니다. 이를 통해 다수의 노드와 Pod에 트래픽이 고르게 분산되며, 확장된 리소스를 효과적으로 활용할 수 있습니다.
     - Ingress Controller를 설정하여, 다양한 도메인 또는 URL 패턴에 따라 트래픽을 특정 마이크로서비스로 라우팅할 수 있습니다. 이를 통해 마이크로서비스별로 트래픽을 관리하고 확장할 수 있습니다.

   - **Application Gateway Ingress Controller (AGIC):**
     - Azure Application Gateway Ingress Controller(AGIC)를 사용하면, L7 로드 밸런싱과 웹 애플리케이션 방화벽(WAF) 기능을 통해 보안이 강화된 트래픽 관리를 수행할 수 있습니다. AGIC는 클러스터 내의 Pod 수가 확장되거나 축소될 때 자동으로 이를 감지하고 트래픽을 적절히 분산시킵니다.

4. **Azure Monitor 및 자동화된 확장 전략:**

   - **모니터링 및 경고 설정:**
     - Azure Monitor와 Application Insights를 사용하여 AKS 클러스터의 리소스 사용량, 트래픽 패턴, 응답 시간 등을 실시간으로 모니터링합니다. 이러한 모니터링 데이터를 통해 클러스터와 Pod의 확장 및 축소가 적시에 이루어지고 있는지 확인할 수 있습니다.
     - 특정 임계값을 초과할 경우 자동으로 확장 정책을 트리거하는 경고(Alert)를 설정하여, 트래픽 증가에 신속하게 대응할 수 있도록 합니다.

   - **예약된 확장 및 축소:**
     - 피크 시간대가 예측 가능한 경우, 예약된 시간에 미리 클러스터를 확장하거나 축소할 수 있는 예약된 스케일링(Scheduled Scaling)을 설정할 수 있습니다. Azure Automation을 통해 특정 시간에 오토스케일링을 트리거하여 리소스를 미리 준비할 수 있습니다.

5. **비용 최적화와 확장성 간의 균형:**

   - **리소스 요구에 맞는 VM 크기 선택:**
     - AKS 노드 풀을 구성할 때, 각 서비스의 리소스 요구에 맞는 VM 크기를 선택하여 확장성과 비용을 최적화합니다. 예를 들어, Standard_D4s_v3와 같은 VM은 일반적인 마이크로서비스에 적합하며, 고성능이 요구되는 서비스는 F 시리즈 또는 E 시리즈 VM을 사용할 수 있습니다.
     - 노드 풀별로 VM 크기를 다양하게 구성하여, 필요에 따라 특정 노드 풀만 확장할 수 있도록 유연하게 관리합니다.

   - **리소스 최적화 전략:**
     - HPA와 클러스터 오토스케일러를 함께 사용하여 필요할 때만 리소스를 확장하고, 불필요한 리소스는 자동으로 축소하여 비용을 절감합니다. 리소스 사용 패턴을 분석해 특정 시간대에만 확장되도록 설정할 수도 있습니다.

**결론:**
- AKS의 클러스터 오토스케일러와 HPA를 통해 시스템의 확장성을 확보하고, 트래픽 증가 시 자동으로 리소스를 확장할 수 있도록 설정함으로써, 서비스 성능을 유지하면서도 효율적인 리소스 사용이 가능합니다.
- Azure Load Balancer와 Ingress Controller를 통해 트래픽을 고르게 분산시키고, 특정 마이크로서비스로 트래픽을 라우팅하여 확장된 리소스를 최적화합니다.
- Azure Monitor 및 예약된 확장 전략을 활용하여, 실시간 모니터링과 자동화된 확장을 통해 트래픽 패턴에 유연하게 대응하고, 리소스와 비용 간의 균형을 유지합니다.
- 이를 통해, 사용자 수요에 따라 동적으로 시스템이 확장되어, 성능 저하 없이 안정적인 서비스를 제공할 수 있습니다.

## 1.6 운영 비용 절감이 중요하며, 피크 시간대 이외에는 리소스 사용을 최소화해야 합니다.

### 요구정의: Azure AKS와 기타 서비스를 활용한 운영 비용 절감 및 리소스 최적화

**목표:**
- 운영 비용 절감이 중요한 목표이며, 특히 피크 시간대 이외에는 리소스 사용을 최소화해야 합니다. 이를 위해 Azure Kubernetes Service(AKS)와 기타 Azure 서비스를 활용하여 효율적인 리소스 관리와 비용 최적화를 실현합니다.

**해결 방안:**

1. **AKS 클러스터의 자동 확장 및 축소:**

   - **클러스터 오토스케일러(Cluster Autoscaler):**
     - AKS 클러스터에서 클러스터 오토스케일러를 사용하여, 필요할 때만 노드를 추가하고 트래픽이 줄어드는 피크 시간대 이외에는 자동으로 노드를 축소하여 비용을 절감합니다.
     - 피크 시간대에만 리소스가 확장되도록 설정하여, 그 외 시간에는 최소한의 노드만 유지하도록 합니다. 이는 특히 트래픽 패턴이 예측 가능한 애플리케이션에 유용합니다.

   - **Spot VM을 활용한 비용 절감:**
     - AKS 노드 풀에서 Spot VM을 사용하여 비용을 절감할 수 있습니다. Spot VM은 Azure의 유휴 컴퓨팅 자원을 활용하므로 저렴한 비용으로 사용할 수 있지만, 필요할 경우 Azure에서 리소스를 회수할 수 있습니다.
     - 비즈니스적으로 덜 중요한 작업이나 일괄 처리 작업은 Spot VM으로 실행하여 비용을 절감하고, 중요한 작업은 일반 VM에서 실행하도록 구성합니다.

2. **Horizontal Pod Autoscaler (HPA)로 Pod 수 최적화:**

   - **HPA를 통한 동적 Pod 관리:**
     - Horizontal Pod Autoscaler(HPA)를 사용하여 CPU 사용률, 메모리 사용량, 또는 사용자 정의 메트릭을 기반으로 Pod의 수를 동적으로 조정합니다. 피크 시간대에는 Pod 수를 늘려 트래픽을 처리하고, 비피크 시간대에는 Pod 수를 줄여 리소스를 절약합니다.
     - 이를 통해 필요할 때만 리소스를 사용하고, 불필요한 리소스 낭비를 줄일 수 있습니다.

   - **사용자 정의 메트릭 기반 확장:**
     - Azure Monitor에서 수집된 사용자 정의 메트릭을 기반으로 HPA를 설정하여, 트래픽 패턴에 따른 최적의 Pod 수를 유지합니다. 예를 들어, 특정 API 응답 시간이나 큐의 대기 길이를 기준으로 Pod을 확장하거나 축소하도록 설정할 수 있습니다.

3. **서버리스 아키텍처 활용:**

   - **Azure Functions를 통한 비용 효율적인 작업 처리:**
     - 서버리스 컴퓨팅 플랫폼인 Azure Functions를 활용하여, 이벤트 기반의 간단한 작업이나 간헐적으로 발생하는 작업을 처리합니다. Azure Functions는 사용된 만큼만 비용이 발생하므로, 특히 비정기적으로 실행되는 작업의 경우 비용 절감에 효과적입니다.
     - 특정 시간이 되면 실행되는 작업이나 트리거가 발생했을 때만 실행되는 작업은 Azure Functions로 구현하여, 고정된 인프라 비용을 줄입니다.

   - **Azure Logic Apps를 통한 워크플로우 자동화:**
     - Azure Logic Apps를 사용해 일정한 규칙에 따라 실행되는 워크플로우를 자동화합니다. 이는 고정된 리소스를 사용하지 않으면서도 필요한 작업을 자동화할 수 있어, 리소스 사용을 최소화하면서도 필요한 기능을 구현할 수 있습니다.

4. **Azure DevTest Labs로 개발 및 테스트 환경 관리:**

   - **DevTest Labs를 활용한 비용 절감:**
     - 개발 및 테스트 환경에서는 Azure DevTest Labs를 사용하여 리소스를 효율적으로 관리합니다. 이 서비스는 비용 통제를 위한 정책을 제공하며, 사용하지 않을 때 자동으로 VM을 중지하거나 삭제하도록 설정할 수 있습니다.
     - 또한, 일정에 따라 개발 환경을 자동으로 시작하거나 중지하는 기능을 통해 불필요한 리소스 사용을 방지합니다.

5. **Azure Reserved Instances와 Azure Hybrid Benefit 활용:**

   - **Reserved Instances (RI) 사용:**
     - 장기간 사용할 계획이 있는 VM에 대해서는 Azure Reserved Instances를 사용하여 최대 72%의 비용 절감을 실현할 수 있습니다. 이는 고정적인 워크로드에 대해 예측 가능한 비용 절감 효과를 제공합니다.
     - Reserved Instances를 통해 클러스터 내에서 지속적으로 운영되는 노드에 대해 비용을 줄일 수 있습니다.

   - **Azure Hybrid Benefit 적용:**
     - 기존의 온프레미스 Windows Server 또는 SQL Server 라이선스를 Azure에서 사용할 경우, Azure Hybrid Benefit을 통해 추가적인 비용 절감을 얻을 수 있습니다. 이는 Azure에서 Windows 기반 VM을 운영할 때 특히 유용합니다.

6. **모니터링 및 최적화:**

   - **Azure Cost Management + Billing:**
     - Azure Cost Management + Billing 도구를 사용하여 리소스 사용량과 비용을 지속적으로 모니터링하고, 비용 절감 기회를 식별합니다. 이 도구를 통해 각 서비스가 차지하는 비용을 세분화하여 분석하고, 과도한 비용이 발생하는 리소스를 최적화할 수 있습니다.
     - 예산 초과 경고를 설정하여 비용이 계획을 초과하지 않도록 관리하며, 최적화 권장 사항을 통해 리소스를 최적화합니다.

   - **Azure Advisor 권장 사항:**
     - Azure Advisor는 비용 최적화, 성능 개선, 보안 강화 등의 권장 사항을 제공하는 도구입니다. 이를 통해 비용 절감을 위한 추가적인 조치를 식별하고 적용할 수 있습니다.
     - Advisor에서 제시하는 비활성 리소스 제거, 사용되지 않는 VM 크기 축소, 예약 인스턴스 활용 등의 권장 사항을 통해 운영 비용을 줄일 수 있습니다.

**결론:**
- Azure AKS의 클러스터 오토스케일러와 HPA를 활용하여 피크 시간대에는 리소스를 확장하고, 비피크 시간대에는 리소스를 축소함으로써 비용을 절감할 수 있습니다.
- 서버리스 아키텍처(Azure Functions, Logic Apps)를 사용하여 간헐적으로 발생하는 작업이나 이벤트 기반 작업을 효율적으로 처리하고, 고정 인프라 비용을 줄입니다.
- Azure Reserved Instances와 Azure Hybrid Benefit을 통해 장기적으로 사용할 리소스에 대해 추가적인 비용 절감 혜택을 얻을 수 있습니다.
- Azure Cost Management + Billing과 Azure Advisor를 사용하여 지속적으로 비용을 모니터링하고 최적화하여, 운영 비용을 효율적으로 관리합니다.
- 이러한 접근 방식을 통해, 피크 시간대 이외에는 리소스 사용을 최소화하면서도 필요한 성능을 유지하여, 전반적인 운영 비용을 효과적으로 절감할 수 있습니다.

